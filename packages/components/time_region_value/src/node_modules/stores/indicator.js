import hierarchy from '@svizzle/atlas/data/dist/NUTS/hierarchy.json';
import yearlyNutsIdToId from '@svizzle/atlas/data/dist/NUTS/yearlyNutsIdToId.json';
import {isIterableEmpty, setIndexAsKey} from '@svizzle/utils';
import {extent} from 'd3-array';
import * as _ from 'lamb';
import {writable, derived} from 'svelte/store';

import {_groups, _lookup} from 'stores/dataset';
import {
	_currentLevel,
	_doFilterRegions,
	_regionsSelection,
} from 'stores/selectedRegions';
import {_selectedYear} from 'stores/selectedYear';
import {_makeColorBins, _makeColorScale} from 'stores/theme';
import {getYear} from 'utils/domain';
import {makeGetIndicatorFormatOf} from 'utils/format';

/* current indicator data */

export const _indicator = writable({
	data: [],
	id: undefined,
});

export const _reconciledIndicator = derived(_indicator, ({data, id}) => {
	const reconciledData = _.map(data, datapoint => {
		const {region_id, region_year_spec} = datapoint;
		const yearlyNutsId = `${region_year_spec}/${region_id}`;
		const atlasId = yearlyNutsIdToId[yearlyNutsId];
		const region = hierarchy[atlasId];

		if (!region) {
			console.log('no region for: ', atlasId); // FIXME, log in production?
		}

		return ({...datapoint, region});
	});

	return ({data: reconciledData, id});
});

export const _availableYears = derived(
	[_indicator, _lookup],
	([{id}, lookup]) => id ? lookup[id].availableYears : []
);

/* current indicator utils */

export const _formatFn = derived(
	[_indicator, _lookup],
	([{id}, lookup]) => {
		const getIndicatorFormat = makeGetIndicatorFormatOf(id);
		const formatFn = getIndicatorFormat(lookup);

		return formatFn
});

export const _getIndicatorValue = derived(_indicator, ({id}) => _.getKey(id));

const makeSetOrderWith = accessor => _.pipe([
	_.groupBy(getYear),
	_.mapValuesWith(_.pipe([
		_.sortWith([_.sorterDesc(accessor)]),
		setIndexAsKey('order'),
	])),
	_.values,
	_.flatten,
]);
const _setOrder = derived(_getIndicatorValue, makeSetOrderWith);

/* data */

export const _levelData = derived(
	[_currentLevel, _reconciledIndicator],
	([currentLevel, {id, data}]) =>
		(id && _.filter(data, ({region_level}) => region_level === currentLevel))
		|| []
);

export const _rankedData = derived(
	[_levelData, _setOrder],
	([levelData, setOrder]) => setOrder(levelData)
);

export const _selectedData = derived(
	[_doFilterRegions, _rankedData, _regionsSelection],
	([doFilterRegions, rankedData, selection]) => _.reduce(
		rankedData,
		(acc, datapoint) => {
			const {region: {id, level, rootId}} = datapoint;
			const isSelected = selection[level][rootId][id].status === 1;

			if (!doFilterRegions || isSelected) {
				acc.push({...datapoint, isSelected});
			}

			return acc;
		},
		[]
	)
);

export const _noData = derived(_selectedData, isIterableEmpty);

export const _yearSelectedData = derived(
	[_selectedData, _selectedYear],
	([selectedData, selectedYear]) => (
		selectedYear &&
		_.filter(selectedData, ({year}) => year === selectedYear)
	) || []
);

// assuming all datapoints in a year have same `region_year_spec`
export const _regionsYearSpec = derived(
	_yearSelectedData,
	yearSelectedData => yearSelectedData[0]?.region_year_spec
);

export const _selectedRegionAtlasIds = derived(
	_yearSelectedData,
	yearSelectedData => _.reduce(
		yearSelectedData,
		(acc, datapoint) => {
			if (datapoint.isSelected) {
				acc.push(datapoint.region.id);
			}

			return acc;
		},
		[]
	)
);

/*
FIXME hopefully we won't need this after we'll have added `atlasId` to topojsons
<ChoroplethG> internally looks for key & key_alt
$: getPayload =
		feature => feature.properties[key] || feature.properties[key_alt];
*/
export const _selectedRegionIds = derived(
	_yearSelectedData,
	yearSelectedData => _.reduce(
		yearSelectedData,
		(acc, datapoint) => {
			if (datapoint.isSelected) {
				acc.push(datapoint.region_id);
			}

			return acc;
		},
		[]
	)
);

/* extent */

export const _valueExtext = derived(
	[_getIndicatorValue, _selectedData],
	([getIndicatorValue, selectedData]) => extent(selectedData, getIndicatorValue)
);

/* color scale, legend */

export const _colorScale = derived(
	[_makeColorScale, _valueExtext],
	([makeColorScale, valueExtext]) => makeColorScale(valueExtext)
);

export const _colorBins = derived(
	[_colorScale, _makeColorBins],
	([colorScale, makeColorBins]) => makeColorBins(colorScale)
);
