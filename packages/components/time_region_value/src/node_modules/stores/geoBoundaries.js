import idToNutsIdByYear from '@svizzle/atlas/data/dist/NUTS/idToNutsIdByYear.json';
import {getAtlasId, makeTopoId, makeTopoURL} from '@svizzle/atlas/src/utils';
import {topoToGeo} from '@svizzle/geo';
import {requestJson} from '@svizzle/request/src/json';
import {isClientSide} from '@svizzle/ui/src/utils/env';
import {makeIsIncluded, transformPaths} from '@svizzle/utils';
import * as _ from 'lamb';
import {derived} from 'svelte/store';
import prune from 'topojson-simplify/src/prune';

import {_regionsYearSpec, _selectedRegionAtlasIds} from 'stores/indicator';
import {_regionSettings} from 'stores/regionSettings';
import {_currentLevel} from 'stores/selectedRegions';

/* cache & fetching utils */

const topoCache = {};
const fetchAndCacheTopojson = async topoAtlasId => {
	let topo = topoCache[topoAtlasId];

	if (!topo) {
		const topoURL = makeTopoURL(topoAtlasId, 'NUTS');
		topo = await requestJson(topoURL);
		topoCache[topoAtlasId] = topo;
	}

	return topo;
}

const geoCache = {};
const getGeojson = ({objectId, topoAtlasId, topojson}) => {
	let geojson = geoCache[topoAtlasId];

	if (!geojson) {
		geojson = topoToGeo(topojson, objectId);
		geoCache[topoAtlasId] = geojson;
	}

	return geojson;
}

/* feature keys, paths, ids */

const _getFeatureKey = derived(
	_regionSettings,
	regionSettings => _.getPath(`properties.${regionSettings.key}`)
);

const _getFeatureAtlasId = derived(
	[_getFeatureKey, _regionSettings, _regionsYearSpec],
	([getFeatureKey, {type}, specYear]) =>
		feature => {
			const regionId = getFeatureKey(feature);
			const atlasId = getAtlasId({regionId, specYear, type});

			return atlasId;
		}
);

export const _getAtlasIdFromRegionId = derived(
	[_regionSettings, _regionsYearSpec],
	([{type}, specYear]) =>
		regionId => getAtlasId({regionId, specYear, type})
);

export const _getRegionIdFromAtlasId = derived(
	_regionsYearSpec,
	regionsYearSpec =>
		atlasId =>
			idToNutsIdByYear[atlasId]
				? idToNutsIdByYear[atlasId][regionsYearSpec]
				: null
);

const _geometriesPath = derived(
	_regionSettings,
	regionSettings => `objects.${regionSettings.objectId}.geometries`
);


/* topojson */

const _topoAtlasId = derived(
	[_currentLevel, _regionSettings, _regionsYearSpec],
	([currentLevel, regionSettings, regionsYearSpec]) =>
		regionSettings && regionsYearSpec &&
		makeTopoId({
			level: currentLevel,
			level0: regionSettings.level0,
			resolution: regionSettings.resolution,
			type: regionSettings.type,
			year: regionsYearSpec,
		})
);

// @sideEffects: fetch
const _fetchedTopojson = derived(
	_topoAtlasId,
	async (topoAtlasId, set) => {
		let topojson = topoCache[topoAtlasId];

		// `set` immediately to drive `_isTopoFetching`
		set(topojson);

		// then `set` here after having fetched if possible
		if (!topojson && topoAtlasId && isClientSide) {
			topojson = await fetchAndCacheTopojson(topoAtlasId);
			set(topojson);
		}
	}
);

export const _isTopoFetching = derived(
	[_fetchedTopojson, _topoAtlasId],
	([fetchedTopojson, topoAtlasId]) =>
		_.isUndefined(fetchedTopojson) && !(topoAtlasId in topoCache)
);

const _isValidRegionKey = derived(
	[_getFeatureAtlasId, _regionSettings],
	([getFeatureAtlasId, {ignoredRegions}]) => _.pipe([
		getFeatureAtlasId,
		_.not(makeIsIncluded(ignoredRegions)),
	])
);

const _removeInvalidRegions = derived(
	[_geometriesPath, _isValidRegionKey],
	([geometriesPath, isValidRegionKey]) => _.pipe([
		transformPaths({
			[geometriesPath]: _.filterWith(isValidRegionKey)
		}),
		prune
	])
);

export const _topojson = derived(
	[_fetchedTopojson, _removeInvalidRegions],
	([fetchedTopojson, removeInvalidRegions]) =>
		fetchedTopojson && removeInvalidRegions(fetchedTopojson)
);

/* geojson */

export const _geojson = derived(
	[_regionSettings, _topojson],
	([{objectId}, topojson]) =>
		topojson &&
		topoToGeo(topojson, objectId)
		// getGeojson({objectId, topoAtlasId, topojson})
		// FIXME TBD: getGeojson caching failing
);

const _featuresIndex = derived(
	[_geojson, _getFeatureAtlasId],
	([geojson, getFeatureAtlasId]) =>
		geojson && _.index(geojson.features, getFeatureAtlasId)
);

export const _filteredGeojson = derived(
	[_featuresIndex, _geojson, _selectedRegionAtlasIds],
	([featuresIndex, geojson, selectedRegionAtlasIds]) =>
		geojson &&
		featuresIndex &&
		_.setPathIn(geojson, 'features',
			_.reduce(selectedRegionAtlasIds, (acc, atlasId) => {
				const feature = featuresIndex[atlasId];
				feature && acc.push(feature);

				return acc;
			}, [])
		)
);
